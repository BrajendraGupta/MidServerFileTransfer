<?xml version="1.0" encoding="UTF-8"?>
<record_update sys_domain="global" table="ecc_agent_script_include">
    <ecc_agent_script_include action="INSERT_OR_UPDATE">
        <active>true</active>
        <description>Script Include run from the mid server to bring files back and attach them to a data source.  The attachment triggers a business rule to do the transform and the attachment.</description>
        <name>MSFT_FileImport</name>
        <script><![CDATA[var MSFT_FileImport = Class.create();
MSFT_FileImport.prototype = {
	initialize: function() {
		_setPackageCalls();//setup package calls
		this.probe_params = this._getProbeParams();
		
		this.debug = gs.getProperty("MSFT.MID.SERVER") == 'true';
		this.debugPrefix = "DEBUG-MSFT: ";
		
		
	},
	
	execute: function(){
		var operation = probe_params.operation;
		var fileListArray = this._getListOfFiles();
		var encData = '';
		//3.3
		if (operation == "import_and_transform") {
			//3.2.
			//3.2.1 : if the import_and_transform; parse the XML and for each row,
			
			/*for (var v = 0, len = fileListArray.length; v < len; v++) {
				this.handleFiles(fileListArray[v]);
			}
 			*/
		} else if (operation == "import_and_attach") {
			this._log("List of files: " + fileListArray + "length: "+ fileListArray.length);
			if(fileListArray.length != 0){
				var inputstream;
				for(var i in fileListArray){
					var fileName = new this.File(fileListArray[i]);
					var fileOutputStream = new this.BufferedWriter(new this.OutputStreamWriter(new this.FileOutputStream(fileName), "UTF-8"));
					//Read file
					if(this.file_type == 'XML'){
						//important note: need to supply character set as argument to FileInputStream function otherwise special charcter are not encoded properly
						inputstream = new this.BufferedReader(new this.InputStreamReader(new this.FileInputStream(fileName), "UTF-8"));
					}
					else if(this.file_type == 'CSV'){
						//important note: if file has sepcial charcter and specific encoding is required supply as argument to FileInputStream
						inputstream = new this.BufferedReader(new this.InputStreamReader(new this.FileInputStream(fileName)));
					}
					else if(this.file_type == 'EXCEL'){
						// uses OOB windows encoding
						inputstream = new this.BufferedReader(new this.InputStreamReader(new this.FileInputStream(fileName)));
					}
					
					else{
						//Error: invalid file type, in future pdf can be added functions
						this.mdLog("Invalid file type");
					}
					//need to handle stream closing
					
					//create data chunk
					var buffer ='';
					
					var isFirstLine = true;
					
					while ((buffer = inputStream.readLine()) != null) {
						if (!isFirstLine || i == 0) {
							fileOutputStream.println(buffer);
							fileOutputStream.flush();
							
							encData = encData + buffer + '\n';
						}
						isFirstLine=false;
					}
					
					//After file is read, post the attachment to target location
					this._postAttachment(encData, fileName);
					fileOutputStream.close();
				}
				
			}
		}
		
	},
	_postAttachment: function(data, fileName) {
		var client = new this.HttpClient();
		
		//Setup creds
		var authScope = new this.AuthScope(this.instance_host + '', this.instance_port+ '', null);
		var credentials = new this.UsernamePasswordCredentials(this.instance_username, this.instance_password);
		client.getState().setCredentials(authScope, credentials);
		
		var ctcr = this._getContentTypeCharSet(this.probe_params.file_type);
		var content_type = ctcr.content_type;
		var charset = ctcr.charset;
		
		//Setup endpoint
		var url = this.instance_url + "api/now/attachment/file?table_name=" +
		this.probe_params.target_table + "&table_sys_id=" + this.probe_params.target_sys_id +
		"&file_name=" + fileName;
		
		this._midLog("Attachment URL: " + url);
		
		var post = new this.PostMethod(url);
		post.setRequestHeader("Accept","application/json");
		if(charset){
			post.getParams().setContentCharset(charset);
		}
		post.setRequestHeader('Content-Type', content_type);
		post.setRequestBody(data);
		post.setDoAuthentication(true);
		
		//
		// Now that we have the HTTP client set up, we are going to submit the request to ServiceNow
		//
		var status = client.executeMethod(post);
		
		//The business rule causes this to come back as 404 rather than the expected 201.
		this._midLog("REST Webservice POST Status: " + status);
		
	},
	/**
 	* Description: Provide Charset and Content Type based on file type
 	* Parameters: filename
 	* Returns: Provide Charset and Content Type based on file type
 	*/
	
	_getContentTypeCharSet: function(fileType) {
		var ext = fileType + '';
		var response = {};
			
			if (ext == 'DOC') {
				response.charset = '';
				response.content_type = "application/msword";
			}
			else if (ext == 'EXCEL') {
				response.charset = '';
				response.content_type = "application/vnd.ms-excel";
			}
			else if (ext == 'XML') {
				response.charset = 'utf-8';
				response.content_type = "text/xml; charset=utf-8";
			}
			else if (ext == 'CSV') {
				response.charset = '';
				response.content_type = "text/csv";
			}
			else{
				response.charset = '';
				response.content_type = "application/octet-stream";
			}
			this._midLog("File ContentType and Charset"+ response);
			return response;
		},
		
		_getListOfFiles: function(){
			//Get the list of files that we will actually process (depending on chosen setting this may not be all files in the directory)
			try{
				var fileLocation = new this.File(this.probe_params.file_path);
				var fileSection = this.probe_params.file_selection_criteria;
				var jsFileID = this.probe_params.file_name.toString();
				var fileListArray, jsFileFilter, fileFilter;
				
				//Here we check if mode of operation is "static filename"
				if(file_selection == 'file_name'){
					jsFileFilter = {
						accept: function(fileObject, fileName) {
							if (fileName.indexOf(jsFileID) == 0) {
								return true;
							} else {
								return false;
							}
						}
					};
					fileFilter = new this.FilenameFilter(jsFileFilter);
					fileFilter.accept(fileLocation, jsFileID);
					
					fileListArray = fileLocation.listFiles(fileFilter);
				}
				//Here we check if mode of operation is "all files with some keyword"
				else if(file_selection == 'file_name_contains'){
					jsFileFilter = {
						accept: function(fileObject, fileName) {
							fileName = fileName + '';
							if (fileName.indexOf(jsFileID) != -1) {
								return true;
							} else {
								return false;
							}
						}
					};
					fileFilter = new this.FilenameFilter(jsFileFilter);
					fileFilter.accept(fileLocation,jsFileID);
					
					fileListArray = fileLocation.listFiles(fileFilter);
				}
				//Here we check if mode of operation is "file name containing regular expression"
				else if(file_selection == 'Reg_exp'){
					
					jsFileFilter = {
						accept: function(fileObject, fileName) {
							var re = new RegExp(jsFileID);
							fileName = fileName + ''; // making sure we have the file name here.
							if (re.test(fileName)) {
								return true;
							} else {
								return false;
							}
						}
					};
					fileFilter = new this.FilenameFilter(jsFileFilter);
					fileFilter.accept(fileLocation, jsFileID);
					
					fileListArray = fileLocation.listFiles(fileFilter);
				}
				else{
					//invalid file selection criteria
					this._mdLog("Invalid file selection criteria provided");
				}
				this._mdLog(fileListArray);
				fileListArray.sort();
				return fileListArray;
			}
			catch(e){
				this._mdLog("Error in the getting File Names");
				return false;
			}
		},
		
		handleFiles: function(){
			
		},
		_setPackageCalls: function(){
			//Setup Package calls
			this.HttpClient = Packages.org.apache.commons.httpclient.HttpClient;
			this.AuthScope = Packages.org.apache.commons.httpclient.auth.AuthScope;
			this.UsernamePasswordCredentials =  Packages.org.apache.commons.httpclient.UsernamePasswordCredentials;
			this.PostMethod = Packages.org.apache.commons.httpclient.methods.PostMethod;
			
			this.File = Packages.java.io.File;
			this.FilenameFilter = Packages.java.io.FilenameFilter;
			this.FileOutputStream = Packages.java.io.FileOutputStream;
			this.FileInputStream = Packages.java.io.FileInputStream;
			this.FileWriter = Packages.java.io.FileWriter;
			this.FileReader = Packages.java.io.FileReader;
			this.BufferedWriter = Packages.java.io.BufferedWriter;
			this.PrintWriter = Packages.java.io.PrintWriter;
			this.ByteArrayOutputStream = Packages.java.io.ByteArrayOutputStream;
			this.BufferedReader = Packages.java.io.BufferedReader;
			this.InputStreamReader = Packages.java.io.InputStreamReader;
			this.OutputStreamWriter = Packages.java.io.OutputStreamWriter;
			
			this.StringUtil = Packages.com.glide.util.StringUtil;
			
			this.Properties = Packages.java.util.Properties;
			this.String = Packages.java.lang.String;
			this.URL = Packages.java.net.URL;
			this.Encrypter = Packages.com.glide.util.Encrypter;
			this.Charset = Packages.java.nio.charset.Charset;
			
			
			
		},
		
		_getProbeParams: function(){
			var probe_params = {};
				probe_params.file_path = probe.getParameter("folder_location");
				probe_params.file_name = probe.getParameter("file_name");
				probe_params.file_type = probe.getParameter("file_type");
				probe_params.file_selection_criteria = probe.getParameter("file_selection_criteria");
				probe_params.operation = probe.getParameter("operation");
				probe_params.target_table = probe.getParameter("target_table");
				probe_params.target_sys_id = probe.getParameter("target_sys_id");
				probe_params.regular_expression = probe.getParameter("regular_expression");
				probe_params.probe_name = probe.getParameter("name");
				probe_params.zipped = probe.getParameter("zipped");
				probe_params.instance_name = probe.getParameter("instance_name");
				probe_params.instance_username = probe.getParameter("mid.instance.username");
				probe_params.instance_password = probe.getParameter("mid.instance.password");
				
				
				var url = new this.URL(probe.getParameter("instance_name"));
				this.instance_host = url.getHost();
				var port = url.getPort();
				this.instance_port = (port == -1) ? 443 : port;
				this._midLog('Instance Host: ' + this.instance_host);
				this._midLog('Instance Port: ' + this.instance_port);
				
				
				this._midLog("The config JSON mapping that was sent: "+probe_params);
				return probe_params;
			},
			
			_midLog : function(msg) {
				if (this.debug) {
					ms.log(this.debugPrefix + msg);
				}
			},
			
			type: 'MSFT_FileImport'
		};]]></script>
        <sys_class_name>ecc_agent_script_include</sys_class_name>
        <sys_created_by>brajendragupta@kpmg.com</sys_created_by>
        <sys_created_on>2017-09-16 20:30:29</sys_created_on>
        <sys_customer_update>true</sys_customer_update>
        <sys_domain>global</sys_domain>
        <sys_domain_path>/</sys_domain_path>
        <sys_id>1390ad3413594b00e9c059722244b0ce</sys_id>
        <sys_mod_count>9</sys_mod_count>
        <sys_name>MSFT_FileImport</sys_name>
        <sys_overrides/>
        <sys_package display_value="Mid Server File Transfer" source="x_kpmg3_mid_server">8591b87813d54b00e9c059722244b0bd</sys_package>
        <sys_policy/>
        <sys_replace_on_upgrade>false</sys_replace_on_upgrade>
        <sys_scope display_value="Mid Server File Transfer">8591b87813d54b00e9c059722244b0bd</sys_scope>
        <sys_update_name>ecc_agent_script_include_1390ad3413594b00e9c059722244b0ce</sys_update_name>
        <sys_updated_by>brajendragupta@kpmg.com</sys_updated_by>
        <sys_updated_on>2017-09-16 23:54:07</sys_updated_on>
    </ecc_agent_script_include>
</record_update>
